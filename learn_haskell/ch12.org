* A Fistful of Monads

When we first talked about functors, we saw that they were a useful concept for values that can be mapped over. Then, we took that concept one step further by introducing applicative functors, which allow us to view values of certain data types as values with contexts and use normal functions on those values while preserving the meaning of those contexts.

Monads are just beefed up applicative functors, much like applicative functors are only beefed up functors.

The Functor type class was to answer the question: when we have a function of type =a -> b= and some data type =f a=, how do we map that function over the data type to end up with =f b=? We saw how to map something over a =Maybe a=, a list =[a]=, an =IO a= etc. We even saw how to map a function =a -> b= over other functions of type =r -> a= to get functions of type =r -> b=.

#+begin_src haskell
fmap :: (Functor f) => (a -> b) -> f a -> f b
#+end_src

Then we saw a possible improvement of functors and said, hey, what if that function =a -> b= is already wrapped inside a functor value? Like, what if we have =Just (*3)=, how do we apply that to =Just 5=? What if we don't want to apply it to =Just 5= but to a =Nothing= instead? Or if we have =[(*2),(+4)]=, how would we apply that to =[1,2,3]=? How would that work even? For this, the Applicative type class was introduced

#+begin_src haskell
(<*>) :: (Applicative f) => f (a -> b) -> f a -> f b
#+end_src

We also saw that we can take a normal value and wrap it inside a data type. For instance, we can take a 1 and wrap it so that it becomes a Just 1. Or we can make it into a [1]. Or an I/O action that does nothing and just yields 1. The function that does this is called =pure=.

*An applicative value can be seen as a value with an added context*. It was neat to see how the Applicative type class allowed us to use normal functions on these values with context and how that context was preserved.

Monads are a natural extension of applicative functors and with them we're concerned with this: if you have a value with a context, =m a=, how do you apply to it a function that takes a normal =a= and returns =a= value with a context? That is, how do you apply a function of type =a -> m b= to a value of type =m a=? or, "*if we have a fancy value and a function that takes a normal value but returns a fancy value, how do we feed that fancy value into the function*"? The =>>== function is pronounced as =bind=.

#+begin_src haskell
(>>=) :: (Monad m) => m a -> (a -> m b) -> m b
#+end_src

When we use the applicative style to have normal functions act on Maybe values, it's similar. All the values have to be Just values, otherwise it's all for Nothing!

#+begin_src haskell
  -- one of the best example for applicative functor
  ghci> max <$> Just 3 <*> Just 6
  Just 6
  ghci> max <$> Just 3 <*> Nothing
  Nothing
#+end_src

>>= takes a monadic value, and a function that takes a normal value and returns a monadic value and manages to apply that function to the monadic value. How does it do that, if the function takes a normal value? Well, to do that, it has to take into account the context of that monadic value.

#+begin_src haskell
ghci> (\x -> Just (x+1)) 1
Just 2
ghci> (\x -> Just (x+1)) 100
Just 101
#+end_src

** The Monad type class

#+begin_src haskell
  class Monad m where
      -- It takes a value and puts it in a minimal default context that still
      -- holds that value. In other words, it takes something and wraps it in a
      -- monad. It always does the same thing as the pure function from the
      -- Applicative type class
      return :: a -> m a

      -- It's like function application, only instead of taking a normal value
      -- and feeding it to a normal function, it takes a monadic value (that is,
      -- a value with a context) and feeds it to a function that takes a normal
      -- value but returns a monadic value.
      (>>=) :: m a -> (a -> m b) -> m b

      (>>) :: m a -> m b -> m b
      x >> y = x >>= \_ -> y

      -- It is seldom used explicitly in our code. Instead, it's used by Haskell
      -- to enable failure in a special syntactic construct for monads
      fail :: String -> m a
      fail msg = error msg
#+end_src

Note that =return= is nothing like the =return= that's in most other languages. It doesn't end function execution or anything, it just *takes a normal value and puts it in a context*. (Both =applicative= and so as =monad= are to open doors for more general operations and functions. One extra interesting thing of the =monad= that is different from the regular =applicative= is the =fail=. It is another way to gracefully handle the failures for the given type class, especially when there are function concatenations - the next function needs to apply itself to the value within the context but also handle the failure that passes by the previous function.)

** Walk the line

#+begin_src haskell
  -- This definition is nuts
  x -: f = f x
#+end_src

#+begin_src haskell
  ghci> 100 -: (*3)
  300
  ghci> True -: not
  False
  ghci> (0,0) -: landLeft 2
    (2,0)
#+end_src

(Please refer to the example. It is great.) We couldn't have achieved this by just using Maybe as an applicative. If you try it, you'll get stuck, because applicative functors don't allow for the applicative values to interact with each other very much. They can, at best, be used as parameters to a function by using the applicative style. The applicative operators will fetch their results and feed them to the function in a manner appropriate for each applicative and then put the final applicative value together, but *there isn't that much interaction going on between them* (*this is the major improvement of =monad= over applicative*). Here, however, each step relies on the previous one's result. On every landing, the possible result from the previous one is examined and the pole is checked for balance. This determines whether the landing will succeed or fail.

In this section, we took some functions that we had and saw that they would work better if the values that they returned supported failure. By turning those values into Maybe values and replacing normal function application with >>=, we got a mechanism for handling failure pretty much for free, because >>= is supposed to preserve the context of the value to which it applies functions. In this case, the context was that our values were values with failure and so when we applied functions to such values, the possibility of failure was always taken into account.

** do notation

In a =do= expression, every line is a monadic value. Because =do= expressions are written line by line, they may look like imperative code to some people. But the thing is, they're just sequential, as each value in each line relies on the result of the previous ones, along with their contexts (in this case, whether they succeeded or failed).

When to use do notation and when to explicitly use >>= is up to you.

In do notation, when we bind monadic values to names, we can utilize pattern matching, just like in let expressions and function parameters. Here's an example of pattern matching in a do expression:

#+begin_src haskell
  justH :: Maybe Char
  justH = do
    (x:xs) <- Just "hello"
    return x
#+end_src

What if this pattern matching were to fail? When matching on a pattern in a function fails, the next pattern is matched. If the matching falls through all the patterns for a given function, an error is thrown and our program crashes. On the other hand, failed pattern matching in =let= expressions results in an error being produced right away, because the mechanism of falling through patterns isn't present in =let= expressions. When pattern matching fails in a =do= expression, the =fail= function is called. It's part of the Monad type class and it enables failed pattern matching to result in a failure in the context of the current monad instead of making our program crash. Its default implementation is this:

#+begin_src haskell
  fail :: (Monad m) => String -> m a
  fail msg = error msg
#+end_src

** The list monad

In this section, we're going to take a look at how to use the monadic aspects of lists to *bring non-determinism into our code in a clear and readable manner*. A value like 5 is deterministic. It has only one result and we know exactly what it is. On the other hand, a value like [3,8,9] contains several results, so we can view it as one value that is actually many values at the same time.

#+begin_src haskell
  instance Monad [] where
    return x = [x]
    xs >>= f = concat (map f xs)
    fail _ = []
#+end_src

#+begin_src haskell
  λ> return 10 :: [] Int
  [10]
  -- like a sick version of list comprehension
  λ> [2, 3, 4] >>= \x -> [x, x*2]
  [2,4,3,6,4,8]
#+end_src

#+begin_src haskell
  -- this is an interesting example
  λ> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
  λ> [1,2] >>= \n -> ['a','b']
  "abab"
  -- Note that the following function has error. It means the two functions use
  -- the same =n=... like enclosure in the monad
  λ> [1,2] >>= \ch -> return (n,ch)

  <interactive>:257:26: error: Variable not in scope: n

  -- OR, we can do the following...
  λ> [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]
  [(1,'a'),(1,'b'),(2,'a'),(2,'b')]

  -- it equals to the function below
  listOfTuples :: [(Int,Char)]
    listOfTuples = do
    n <- [1,2]
    ch <- ['a','b']
    return (n,ch)
#+end_src

In fact, *list comprehensions are just syntactic sugar for using lists as monads* (?!!!!!!!!!!!!!!!!!!!). In the end, list comprehensions and lists in do notation translate to using >>= to do computations that feature non-determinism.

** Monad laws

Haskell allows any type to be an instance of any type class as long as the types check out. It can't check if the monad laws hold for a type though, so if we're making a new instance of the Monad type class, we have to be reasonably sure that all is well with the monad laws for that type. We can rely on the types that come with the standard library to satisfy the laws, but later when we go about making our own monads, we're going to have to manually check the if the laws hold. But don't worry, they're not complicated.

1. =return x >>= f= is the same damn thing as =f x=
2. =m >>= return= is no different than just =m=
3. Doing =(m >>= f) >>= g= is just like doing =m >>= (\x -> f x >>= g)=
