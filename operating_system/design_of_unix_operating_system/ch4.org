Every file o n a UNIX system has a unique =inode=. The =inode= contains the information necessary for a process to access a file, such as file ownership, access rights, file size, . and location of the file's data in the file system. Processes access files by a well defined set of system calls and specify a file by a character string that is the path name. Each path name uniquely specifies a file, and the kernel converts the path name to the file's =inode=.

The algorithms for the internal representation of the files occupy the layer above the buffer cache algorithms. The algorithm =iget= returns a previously identified =inode=, possibly reading it from disk via the buffer cache, and the algorithm =iput= releases the =inode=. The algorithm =bmap= sets kernel parameters for accessing a file. The algorithm =namei= converts a user-level path name to an =inode=, using the algorithms =iget=, =iput=, and =bmap=. Algorithms =alloc= and free allocate and free disk blocks for files, and algorithms =ialloc= and ifree assign and free =inodes= for files.

The most striking difference between an in-core =inode= and a buffer header is the in-core reference count, which counts the number of active instances of the file. An =inode= is active when a process allocates it, such as when opening a file. An =inode= is on the free list only if its reference count is 0, meaning that the kernel can reallocate the in-core =inode= to another disk =inode=. The free list of =inodes= thus serves as a cache of inactive =inodes=: If a process attempts to access a file whose =inode= is not currently in the in-core =inode= pool, the kernel reallocates an in-core =inode= from the free list for its use. On the other hand, a buffer has no reference count; it is on the free list if and only if it is unlocked.

Regarding the algorithm =iget=, if the kernel attempts to take an =inode= from the free list but finds the free list empty, it reports an error. This is different from the philosophy the kernel follows for disk buffers, where a process sleeps until a buffer becomes free. Processes have control over the allocation of =inodes= at user level via execution of open and close system calls, and consequently the kernel cannot guarantee when an =inode= will become available. Therefore, a process that goes to sleep waiting for a free =inode= to become available may never wake up. Rather than leave such a process "hanging," the kernel fails the system call. However, processes do not have such control over buffers: Because a process cannot keep. a buffer locked across system calls, the kernel can guarantee that a buffer will become free soon, and a process therefore sleeps until one is available.

To summarize, the =iget= algorithm is used toward the beginning of system calls when a process first accesses a file. The algorithm returns a locked =inode= structure with reference count 1 greater than it had previously been. The in-core =inode= contains up-to-date information on the state of the file. The kernel unlocks the =inode= before returning from the system call so that other system calls can access the =inode= if they wish.

To keep the =inode= structure small yet still allow large files, the table of contents of disk blocks conforms to that shown in Figure 4.6. The System V UNIX system runs with 13 entries in the =inode= table of contents, but the principles are independent of the number of entries. The blocks marked "direct" in the figure contain the numbers of disk blocks that contain real data. The block marked "single indirect" refers to a block that contains a list of direct block numbers. To access the data via the indirect block, the kernel must read the indirect block, find the appropriate direct block entry, and then read the direct block to find the data. The block marked "double indirect" contains a list of indirect block numbers, and the block marked "triple indirect" contains a list of double indirect block numbers.

In principle, the method could be extended to support "quadruple indirect blocks, "quintuple indirect blocks," and so on, but the current structure has sufficed in practice. Assume that a logical block on the file system holds 1K bytes and that a block number is addressable by a 32 bit (4 byte) integer. Then a block can hold up to 256 block numbers. The maximum number of bytes that could be held in a file is calculated at well over 16 gigabytes, using 10 direct blocks and 1 indirect, 1 double indirect, and 1 triple indirect block in the =inode=. Given that the file size field in the =inode= is 32 bits, the size of a file is effectively limited to 4 gigabytes (2^32).

The conversion of a large byte offset, particularly one that is referenced via the triple indirect block, is an arduous procedure that could require the kernel to access three disk blocks in addition to the =inode= and data block. Even if the kernel finds the blocks in the buffer cache, the operation is still expensive, because the kernel must make multiple requests of the buffer cache and may have to sleep awaiting locked buffers. How effective is the algorithm in practice? That depends on bow the system is used and whether the user community and job mix are such that the kernel accesses large files or small files more frequently. It has been observed [Mullender 84], however, that most files on UNIX systems contain less than 10K bytes, and many contain less than 1K bytes!1 Since 1OK bytes of a file are stored in direct blocks, most file data can be accessed with one disk access. So in spite of the fact that accessing large files is an expensive operation, accessing common-sized files is fast.

The directories are the files that give the file system its hierarchical structure; they play an important role in conversion of a file name to an =inode= number. A directory is a file whose data is a sequence of entries, each consisting of an =inode= number and the name of a file contained in the directory. Because the kernel works internally with =inodes= rather than with path names, it converts the path names to =inodes= to access files. The algorithm =namei= parses the path name one component at a time, converting each component into an =inode= based on its name and the directory being searched, and eventually returns the =inode= of the input path name.

The =inode= is the data structure that describes the attributes of a file, including the layout of its data on disk. There are two versions of the =inode=: the disk copy that stores the =inode= information when the file is not in use and the in-core copy that records information about active files. Algorithms =ialloc= and =ifree= control assignment of a disk =inode= to a file during the =creat=, =mknod=, =pipe=, and =unlink= system calls, and the algorithms =iget= and =iput= control the allocation of in-core =inodes= when a process accesses a file. Algorithm =bmap= locates the disk blocks of a file, according to a previously supplied byte offset in the file. Directories are files that correlate file name components to =inode= numbers. Algorithm =namei= converts file names manipulated by processes to =inodes=, used internally by the kernel. Finally, the kernel controls assignment of new disk blocks to a file using algorithms =alloc= and =free=.
