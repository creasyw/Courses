The UNIX system contains two types of devices, block devices and raw or character devices. As defined in Chapter 2, block devices, such as disks and tapes, look like random access storage devices to the rest of the system; character devices include all other devices such as terminals and network media. Block devices may have a character device interface, too.

The kernel to driver interface is described by the block device switch table and the character device switch table. Each device type has entries in the table that direct the kernel to the appropriate driver interfaces for the system calls. The open and close system calls of a device file funnel through the two device switch tables, according to the file type. The =mount= and =umount= system calls also invoke the device open and close procedures for block devices. =Read=, =write=, and =ioctl= system calls of character special files pass through the respective procedures in the character device switch table. Read and write system calls of block devices and of files on mounted file systems invoke the algorithms of the buffer cache, which invoke the device strategy procedure. Some drivers invoke the strategy procedure internally from their read and write procedures.

For system calls that use file descriptor, the kernel follows pointers from the user file descriptor to the kernel file table and =inode=, where it examines the file type and accesses the block or character device switch table, as appropriate. It extracts the major and minor numbers from the =inode=, uses the major number as an index into the appropriate table, and calls the driver function according to the system call being made, passing the minor number as a parameter. An important difference between system calls for devices and regular files is that the inode of a special file is not locked while the kernel executes the driver. Drivers frequently sleep, waiting for hardware connections or for the arrival of data, so the kernel cannot determine how long a process will sleep. If the =inode= was locked, other processes that access the =inode= (via the stat system call, for example) would sleep indefinitely because another process is asleep in the driver.

The device driver interprets the parameters of the system call as appropriate for the device. A driver maintains data structures that describe the state of each unit that it controls; driver functions and interrupt handlers execute according to the state of the driver and the action being done.

Because the interface between device drivers and the underlying hardware is machine dependent, no standard interfaces exist at this level. For both memory­mapped I/O and programmed I/O, a driver can issue control sequences to a device to set up direct memory access (DMA) between the device and memory. The system allows bulk DMA transfer of data between the device and memory in parallel to CPU operations, and the device interrupts the system when such a transfer has completed. The driver sets up the virtual memory mapping so that the correct locations in memory are used for DMA.

High-speed devices can sometimes transfer data directly between the device and the user's address space, without intervention of a kernel buffer. This . results in higher transfer speed because there is one less copy operation in the kernel, and the amount of data transmitted per transfer operation is not bounded by the size of kernel buffers. Drivers that make use of this "raw" 110 transfer usually invoke the block strategy interface from the character read and write procedures if they· have a block counterpart.

Because of the high level of disk traffic typical of UNIX systems, the disk driver must maximize data throughput to get the best system performance. Most modern disk controllers take care of disk job scheduling, positioning the disk arm, and transferring data between the disk and the CPU; otherwise, the disk driver must do these tasks.
