Pipes (unnamed) suffer from th,e drawback that they are known only to processes which are descendants of the process that invoked the pipe system call: Unrelated processes cannot communicate via pipes. Although named pipes allow unrelated processes to communicate, they cannot generally be used across a network, nor do they readily lend themselves to setting up multiple communications paths for different sets of communicating processes: it is impossible to multiplex a named pipe to provide private channels for pairs of communicating processes. Arbitrary processes can also communicate by sending signals via the kill system call, but the "message" consists only of the signal number.

The UNIX system provides a primitive form of interprocess communication for tracing processes, useful for debugging. A debugger process, such as sdb, spawns a process to be traced and controls its execution with the ptrace system call, 1>etting and clearing break points, and reading and writing data in its virtual address space. Process tracing thus consists of synchronization of the debugger process and the traced process and controlling th� execution of the traced process.

Typically, the parent (debugger) process would have meanwhile entered a user­level loop, waiting to be awakened by the traced process. When the traced process awakens the debugger, the debugger returns from wait, reads user input commands, and converts them to a series of =ptrace= calls to control the child (traced) process. When executing the =ptrace= system call, the kernel verifies that the debugger has a child whose ID is pid and that the child is in the traced state and then uses a global trace data structure to transfer data between the two processes. It locks the trace data structure to prevent other tracing processes from overwriting it, copies cmd, addr, and data into the data structure, wakes up the child p,.ocess and puts it into the "ready-to-run" state, then sleeps until the child responds. When the child resumes �xecution (in kernel mode), it does the a ppropriate trace command, writes its reply into the trace data structure, then awakens the debugger. Depending on the command type, the child may reenter the trace state and wait for a new command or return from handling signals and resume execution. When the debugger resumes execution, the kernel saves the "return value" supplied by th� traced process, unlocks the trace data structure, and returns to the user.

=Stat= returns various statistics about the process. This method removes three disadvantages of =ptrace=. First, it is faster, because a debugger process can transfer more data per system call than it can with =ptrace=. Second, a debugger can trace arbitrary processes, not necessarily a child process. Finally, the traced process does not have to make prior arrangement to allow tracing; a debugger can trace existing processes. As part of the regular file protection mechanism, only a superuser can debug processes that are setuid to root.

The UNIX System V IPC package consists of three mechanisms. *Messages* allow processes to send formatted data streams to arbitrary processes, *shared memory* allows processes to share parts of their virtual address space, and *semaphores* allow processes . to synchronize execution.

There are several similarities between the file system and the IPC mechanisms. The =get= system calls are similar to the =create= and =open= system calls, and the =control= system calls contain an option to remove descriptors from the system, similar to the =unlink= system call. But no operations are analogous to the file system close system call. Thus, the kernel has no record of which processes can access an IPC mechanism, and, indeed, processes can access an IPC mechanism if they guess the correct ID and if access permissions are suitable, even though they never did a =get= call. The kernel cannot clean up unused IPC structures automatically, because it never knows when they are no longer needed. Errant processes can thus leave unneeded and unused structures cluttering the system. Although the kernel can save state information and data in the IPC structures after the death of a process, it is better to use files for such purposes.

The IPC mechanisms introduce a new name space, keys, instead of the traditional; all pervasive files. It is difficult to extend the semantics of keys across a network, because they may describe different objects on different machines: In short, they were designed for a single-machine environment. File names are more amenable to a distributed environment. Use of keys instead of file names also means that the IPC facilities are an entity unto themselves, useful for special-purpose applications, but lacking the tool-building capabilities inherent in pipes and files, for example. Much of their functionality can be duplicated using other system facilities, so, aesthetically, they should not be in the kernel. However, they provide better performance for closely cooperation application packages than standard file system facilities.
