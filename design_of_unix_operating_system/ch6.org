The kernel contains a process table with an entry that describes the state of every active process in the system. The =u area= contains additional information that controls the operation of a process. The process table entry and the =u area= are part of the context of a process. The aspect of the process context that most visibly distinguishes it from the context of another process is, of course, the contents of its address space.

Two kernel · data structures describe the state of a process: the process table entry and the =u area=. The process table contains fields that must always be accessible to the. kernel, but the =u area= contains fields that need to be accessible   only to the running process. Therefore, the kernel allocates space for the =u area= only when creating a process: It does not need =u area=s for process table entries that do not have processes.

The kernel contains a region table and allocates an entry from the table for each-active region in the system. Each process contains a private per process region table, called a pregion for short. Pregion entries may exist in the process table, the =u area=, or in a separately allocated area of memory, dependent on the implementation, but for simplicity, assume that they are part of the-process table entry. Each pregion entry points to a region table entry and contains the starting virtual address of the region in the process. Shared regions may have different virtual addresses in each process. The pregion entry also contains a permission field that indicates the type of access allowed the process: read-only, read-write, or read-execute. The pregion and the region structure are analogous to the file table and the =inode= structure in the file system: Several processes can share parts of their address space via a region, much as they can share access to a file via an =inode=; each process accesses the region via a private pregion entry, much as it accesses the =inode= via private entries in its user file descriptor table and the kernel file table.

The concept of the region is independent of the memory management policies implemented by the operating system. Memory management policy refers to the actions the kernel takes to insure that processes share main memory fairly.

The kernel correlates the virtual addresses of a region to their physical machine addresses by mapping the logical page numbers in the region to physical page numbers on the machine.

Every process has a private =u area=, yet the kernel accesses it as if there were only one =u area= in the system, that of the running process. The kernel changes its virtual address translation map according to the executing process to access the correct =u area=. When compiling the operating system, the loader assigns the variable u, the name of the =u area=, a fixed virtual address. The value of the =u area= virtual address is known to other parts of the kernel, in particular, the module that does the context switch. The kernel knows where in its memory management tables the virtual address translation for the =u area= is done, and it can dynamically change the address mapping of the =u area= to another physical address. The two physical addresses represent the =u area=s of two processes, but the kernel access�s them v1a the same virtual address.

A process can access its =u area= when it executes in kernel mode but not when it executes in user mode. Because the kernel can access only one =u area= at a time by its virtual address, the =u area= partially defines the context of the process that is running on the system. When the kernel schedules a process for execution, it finds the corresponding =u area= in physical memory and makes it accessible by its virtual address.

The context of a process consists of the contents of its (user) address space and the contents of hardware registers and kernel data structures that relate to the process. Formally, the context of a process1 is the union of its user-level context; register context, and system-level context. The user-level context consists of the process text, data, user stack, and shared memory that occupy the virtual address space of the procesS. Parts of the virtual address space of a process that periodically do not reside in main memory because of swapping or paging still constitute a part of the user-level context.

The register context consists of the following four components. First, the program counter specifies the address of the next instruction the CPU will execute; the address is a virtual address in kernel or in user memory space. Second, the processor status register (PS) specifies the hardware status of the machine as it relates to the process - the result of a recent computation resulted in a zero, positive or negative result, or that a register overflowed and a carry bit is set, and so on; the current processor execution level (for interrupts) and the current and most recent modes of execution <such as kernel, user); the current execution mode determines whether a process can execute privileged instructions and whether it can access kernel address- space. Third, the stack pointer contains the current address of the next entry in the kernel or user stack, determined by the mode of execution. At last, the general-purpose registers contain data generated by the process during its execution.

The system-level context of a process has a "static part" (first three ttems of tne following list) and a "dynamic part" (last two items).

1. The process table entry of a process defines the state of a process and contains control information that is always accessible to the kernel .
2. The =u area= of a process contains process control information that need be accessed only in the context of the process. General control parameters such as the process priority are stored in the process table because they must · be accessed outside the process context.
3. Pregion entries, region tables and page tables, define the mapping from virtual • to physical addresses and therefore define the text, data, stack, and other regions of a process. If several processes share common regions, the regions are considered part of the context of each process, because each process manipulates the regions independently. Part of the memory management task is to indicate which parts of the virtual address space of a process are not memory resident.
4. The kernel stack contains the stack frames of kernel procedures as. a process executes in kernel mode. Although all processes execute the identical kernel code, they have a private copy of the kernel stack that specifies their particular invocation of the kernel functions. The kernel must be able to recover the contents of the kernel stack and the position of the stack pointer to resume execution of a process in kernel mode. System implementations frequently place the kernel stack in the process =u area=, but it is logically independent and can exist in an independently allocated area of memory. The kernel stack is empty when the process executes in user mode.
5. The dynamic part of the system-level context of a process consists of a set of layers, visualized as a last-in-first-out stack. Each system-level context layer contains the necessary information to recover the previous layer, including the register context of the previous level.

The kernel pushes a context layer when an interrupt occurs, when a process makes a system call, or when a process does a context switch. It pops a context layer when the kernel returns from handling an interrupt, when a process returns to user mode after the kernel completes execution of a system call, or when a process does a context switch. The context switch thus entails a push and a pop of a system-level context layer: The kernel pushes the context layer af the old process and-pops the context layer of the new process. The process table entry stores the necessary information to recover the current context layer.

A process runs within its context or, more precisely, within its current context layer. The number of context layers is bounded by the number of interrupt levels the machine supports.

The system is responsible for handling interrupts, whether they result from hardware (such as from the clock or from peripheral devices), from a programmed interrupt (execution of instructions designed to cause "software interrupts"), or from exceptions (such as page faults). If the CPU is executing at a lower processor execution level than the level of the interrupt, it accepts the interrupt before decoding the next instruction and raises the processor execution level, so that no other interrupts of that level (or lower) can happen while it handles the current interrupt, preserving the integrity of kernel data structures.

The C compiler uses a predefined library of functions (the C library) that have the names of the system calls, thus resolving the system call references in the user program. to what would otherwise be undefined names. The library functions typically invoke an instruction that changes the process execution mode to kernel mode and causes the kernel to start executing code for system calls. The ensuing discussion refers to the instruction as an operating system trap. The library routines execute in user mode, but the system call interface is, in short, a special case of an interrupt handler. The library functions pass the kernel a unique number per system call in a machine-dependent way - either as a parameter to the operating system trap, in a particular register, or on the stack - and the kernel thus determines the specific system call the user is invoking.

In handling the operating system trap, the kernel looks up the system call number in a table to find the address of the appropriate kernel routine that is the entry point for the system call and to find the number of parameters the system call expects. The kernel calculates the (user) address of the first parameter to the system call by adding (or subtracting, depending on the direction of stack growth) an offset to the user stack pointer, corresponding to the number of parameters to the system call. Finally, it copies the user parameters to the =u area= and calls the appropriate system call routine. After executing the code for the system call, the kernel determines whether there was error. If so, it adjusts register locations in the saved user register context, typically setting the "carry" bit for the PS register and copying the error number into the register 0 location. If there were no errors in the execution of the system call, the kernel clears the "carry" bit in the PS register and copies the appropriate return values from the system call into the locations for registers 0 and 1 in the saved user register context. When the kernel returns from the operating system trap to user mode, it returns to the library instruction after the trap. The library interprets the return values from the kernel and returns a value to the user program.

The kernel permits a context switch under four circumstances: when a process puts itself to sleep, when it exits, when it returns from a system call to user mode but is not the most eligible process to run, or when it returns to user mode after the kernel completes handling an interrupt but it is not the most eligible process to run. The kernel ensures integrity and consistency of internal data structures by prohibiting arbitrary context switches.

The procedure for a context switch is similar to the procedures for handling interrupts and system calls, except that the kernel restores the context layer of a different process instead of the previous context layer of the same process. The reasons for the context switch are irrelevant. Similarly, the choice of which process to schedule next.is a policy decision that does not affect the mechanics of the context switch.

The code that implements the context switch on UNIX systems is usually the most difficult to understand in the operating system, because function calls give the appearance of not returning on some occasions and materializing from nowhere on others. This is because the kernel; in many implementations, saves the process context at one point in the code but proceeds to execute the context switch and scheduling algorithms in the context of the "old" process. When it later restores the context of the process, it resumes execution according to the previously saved context. To differentiate between the case where the kernel resumes the context of a new process and the case where it continues to execute in the old context after having saved it, the return values of critical functions may vary, or the program counter where the kernel executes may be set artificially.

The kernel has operations to lock and unlock a region, independent of the operations to allocate and free a region, just as the file system has lock-unlock and allocate-release operations for =inode=s. Thus the kernel can lock and allocate a region and later unlock it without having to free the region. Similarly, if it wants to manipulate an allocated region, it can lock the region to prevent access by other processes and later unlock it.

To distinguish the types of sleep states, the kernel. sets the scheduling priority of the sleeping process when it enters the sleep state, based on the sleep priority parameter. That is, it invokes the sleep algorithm with a priority value, based on its knowledge that the sleep event is sure to occur or not. If the priority is above a threshold value, the process will not wake up prematurely on receipt of a signal but will sleep until the event it is waiting for happens. But if the priority value is below the threshold value, the process will awaken immediately on receipt of the signal.
