Each =open= call results in allocation of a unique entry in the user file descriptor table and in the kernel file table, but the kernel contains at most one entry per file in the in-core =inode= table.

The first three user file descriptors (0, 1, and 2) are called the standard input, standard output, and standard error file descriptors. Processes on UNIX systems conventionally use the standard input descriptor to read input data, the standard output descriptor to write output data, and the standard error descriptor to write error data (messages). Nothing in the operating system assumes that these file descriptors are special.

When a process invokes the read system call, the kernel locks the =inode= for the duration . of the call. Afterwards, it could go to sleep reading a buffer associated . with data or with indirect blocks of the =inode=. If another process were allowed to change the file while the first process was sleeping, read could return inconsistent data. Hence, the =inode= is left locked for the duration of the read call, affording the process a consistent view of the file as it existed at the start of the call.

The kernel can preempt a reading process between system calls in user mode . and schedule other processes to run. Since the =inode= is unlocked at the end of a system call, nothing prevents other processes from accessing the file and changing its contents. It would be unfair for the system to keep an =inode= locked from the time a process opened the file until it closed the file, because one process could keep a file open and thus prevent other processes from ever accessing it. To avoid such problems, the kernel unlacks the =inode= at the end of each system call that uses it. If another process changes the file between the two read system calls by the first process, the first process may read unexpected data, but the kernel data structures are consistent.

> As a result, it requires a lock to both read and write a file to keep the content consistent (not a mix of old and updated contents).

The write proceeds block by block, but the kernel uses a delayed write (Chapter 3) to write the data to disk, caching it in case another process should read or write it soon and avoiding extra disk operations. Delayed write is probably most effective for pipes, because another process is reading the pipe and removing its data (Chapter 5) . But even for regular files, delayed write is effective if the file is created temporarily and will be read soon.

When the system is first booted, process 0 makes the file system root its current directory during initialization. It executes the algorithm =iget= on the root =inode=, saves it in the =u area= as its current directory, and releases the =inode= lock. When a new process is created via the fork system call, the new process inherits the current directory of the old process in its u area, and the kernel increments the =inode= reference count accordingly.

Pipes allow transfer of data between processes in a first-in-first-out manner (FIFO) , and they also allow synchronization of process execution. Their implementation allows processes to communicate even though they do not know what processes are on the other end of the pipe. There are two kinds of pipes: named pipes and, for lack of a better term, unnamed pipes, which are identical except for the way that a process initially accesses them. Processes use the open system call for named pipes, but the pipe system call to create an unnamed pipe. Afterwards, processes use the regular system calls for files, such as read, write, and close when manipulating pipes. Only related processes, descendants of a process that issued the pipe call, can share access to unnamed pipes.

A named pipe is a file whose semantics are the same as those of an unnamed pipe; except that it has a directory entry and is accessed by a path name. Processes open named pipes in the same way that they open regular files and, hence, processes that are not closely related can communicate. Named pipes permanently exist in the file system hierarchy (subject to their removal by the unlink system call) , but unnamed pipes are transient: When all processes finish using the pipe, the kernel reclaims its =inode=.

The algorithm for opening a named pipe is identical to the algorithm for opening a regular file. However, before completing the system call, the kernel increments the read or write counts in the =inode=, indicating the number of processes that have the named pipe open for reading or writing. A process that opens the named pipe for reading will sleep until another process opens the named pipe for writing, and vice versa. Depending on whether the process opens the named pipe for reading or writing, the kernel awakens other processes that were asleep, waiting for a writer or reader process (respectively) on the named pipe.

Analyzing the implementation of pipes, the process interface is consistent with that of regular files, but the implementation differs because the kernel stores the read and write offsets in the =inode= instead of in the file table. The kernel must store the offsets in the =inode= for named pipes so that processes can share their values: They cannot share values stored in file table entries because a process gets a new file table entry for each open call. However, the sharing of read and write offsets in the =inode= predates the implementation of named pipes. Processes with access to unnamed pipes share access to the pipe through common file table entries, so they could conceivably store the read and write offsets in the file table entry, as is done for regular files. This was not done, because the low-level routines in the kernel no longer have access to the file table entry: The code is simpler because the processes share offsets stored in the =inode=.

The kernel orders its writes to disk to minimize file system corruption in event of system failure. For instance, when it removes a file name from its parent directory, it writes the directory synchronously to the disk - before it destroys the contents of the file and frees the =inode=. The kernel also frees =inode=s and disk blocks in a specific order to minimize corruption inÂ· event of system failure. If the system first writes the =inode= to disk anJ the system crashes, a user would not notice anything wrong with the file system when the system is rebooted. The data blocks that previously belonged to the file would be inaccessible to the system, but users would notice no apparent corruption. The =fsck= program also finds the task of reclaiming unlinked disk blocks easier than the clean-up it would have to do for the first sequence of events.

The =inode= is the interface between the abstract file system and the specific file system. A generic in-core =inode= contains data that is independent of particular file systems, and points to a file-system-specific =inode= that contains file-system-specific data. The file-system-specific =inode= contains information such as access permissions and block layout, but the generic =inode= contains the device number, =inode= number, file type, size, owner, and reference count. Other data that is file-system-specific includes the super block and directory structures.
