On a time sharing system, the kernel allocates the CPU to a process for a period of time called a time slice or time quantum, preempts the process and schedules another one when the time slice expires, and reschedules the process to continue execution at a later time. The scheduler function on the UNIX system uses relative time of execution as a parameter to determine which process to schedule next. Every active process has a scheduling priority; the kernel switches context to that of the process with the highest priority when it does a context switch. The kernel recalculates the priority of the running process when it returns from kernel mode to user mode, and it periodically readjusts the priority of every "ready-to-run" process in user mode.

The scheduler on the UNIX system belongs to the general class of operating system schedulers known as round robin with multilevel feedback, meaning that the kernel allocates the CPU to a process for a time quantum, preempts a process that exceeds its time quantum, and feeds it back into one of several priority queues. A process may need many iterations through the "feedback loop" before it finishes. When the kernel does a context switch and restores the context of a process, the process resumes execution from the point where it had been suspended.

Each process table entry contains a priority field for process scheduling. The priority of a process in user mode is a function of its recent CPU usage, with processes getting a lower priority if they have recently used the CPU. The range of process priorities can be partitioned into two classes: user priorities and kernel priorities. Each class contains several priority values, and each priority has a queue of processes logically associated with it. Processes with user­level priorities were preempted on their return from the kernel to user mode, and processes with kernel-level priorities achieved them in the sleep algorithm. User­level priorities are below a threshold value, and kernel-level priorities are above the threshold value. Kernel-level priorities are further subdivided: Processes with low kernel priority wake up on receipt of a signal, but processes with high kernel priority continue to sleep.

The kernel calculates the priority of a process in specific process states.

1. It assigns priority to a process about to go to sleep, correlating a fixed, priority value with the reason for sleeping. The priority does not depend on the run­ time characteristics of the process (1/0 bound or CPU bound) , but instead is a constant value that is hard-coded for each call to sleep, dependent on the reason the process is sleeping. Processqs that sleep in lower-level algorithms tend to cause more syst em bottlenecks the longer they are inactive; hence they receive a higher priority than processes that would cause fewer system bottlenecks.
2. The kernel adjusts the priority of a process that returns from kernel mode to user mode. The proce!:.; may have previously entered the sleep state, changing its priority to a kernel-level priority that must be lowered to a user-level priority when returning to user mode. Also, the kernel penalizes the executing process in fairness to other processes, since it had just used valuable kernel resources.
3. The clock handler adjusts the priorities of all processes in user mode at 1 second intervals (on System V) and causes the kernel to go through the scheduling algorithm to prevent a process from monopolizing use of the CPU.

The clock may interrupt a process several times during its time quantum; at every clock interrupt, the clock handler increments a field in the process table that records the recent CPU usage of the process. Once a second, the clock handler also adjusts the recent CPU usage of each process according to a decay function.

The principl e of the fair share scheduler is to divide the user community into a set of fair share groups, such that the members of each group are subject to the constraints of the regular process scheduler relative to other processes in the group. However, the system allocates its CPU time proportionally to each group, regardless of how many processes are in the groups.

Another term is added to the formula for computation of. process priority, namely, a "fair share group priority." Each process has a' new field in its u area that points to a fair share CPU usage field, shared by all processes in the fair share group. The clock interrupt handler increments the fair share group CPU usage field for the running process, just as it increments the CPU usage field of the running process and decays the values of all fair share group CPU usage fields once a second. When calculating process priorities, a new component of the calculation is the group CPU usage, normalized according to the amount of CPU time allocated to the fair share group. The more CPU time processes in a group received recently, the higher the numerical value of the group CPU usage field is and, therefore, the lower the priority for all the processes in the fair share group.
